[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15791754&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software engineering is basically defined as the application of scientific knowledge, skills experience and principles to resolve problems and optimize  by creating, testing and implementing software.  In other words, it is the application of scientific methods to come up with or generate a software for a particular purpose.

A well developed software is reliable and qualitative. A fit for purpose software provide efficiency and enhances industrial development process through automation, improved productivity, cost effectiveness, timeliness, better management practices. The advent of software engineering has also brought about scalability which in turn, enables faster time-to-market, increases reliability, improves user experience, innovation, brings about business growth through competitive advantage and reduced cost. it also enhances collaboration amongst stakeholders in the industry.

Identify and describe at least three key milestones in the evolution of software engineering.

Notably, software engineering gained fame during the period of the initial space exploration in the 50s and 60s then  structured programming and modular design became a centeral focus in the 70s. Software development tools were later developed in the 80s with the introduction of the object orientated 


List and briefly explain the phases of the Software Development Life Cycle.

The phases of Software Development Life Cycle are:
1. Documentation of Development Process 
2. Determining phase entry and exit criteria
3. Feasibility study
4. Requirements analysis and specification
5. Design 
6. Coding and unit testing (implementation)
7. Integration and system testing (testing)
8. Maintenance
9. Phase containment of errors

DEVELOPMENT PROCESS AND DOCUMENTATION

Software development process describes the life cycle activities
more precisely and elaborately in its life cycle. It also describe various activities, prescribe a specific methodologies to carry out
the activities, and also recommends the the specific documents and other
artifacts that should be produced at the end of each phase.

It is crucial for an organization to have well documented software 
development process. Lack of proper and adequate documentation right from the ideation stage can create
several problems during development. Problems that may crop up when a development process is
not adequately documented include:
- Because documented process model ensures that every activity in the life
cycle is accurately defined and wherever necessary the
methodologies for carrying out the respective activities are described. Therefore, lack of
documentation portends loosely defined, disorderly activities thus leading to confusion and misinterpretation.
- It shows ineptitude, lack of commitment and ethics.
- time and resource wages by reinventing the wheel. Duplicating a pre-existing solution.
- difficulty in software maintenance and update. 

DETERMINING ENTRY AND EXIT PHASE
The phase entry (or exit) criteria is usually expressed as a set of
conditions that needs to be satisfied for a phase to start (or to
complete). If the entry or exit phase criteria are not clearly stated or defined then void for ambiguity will be created that could lead to confusion. Therefore set conditions for entry and exit of each phase are stated at this point.

FEASIBILITY STUDY
Feasibility study is needed to determine the economic and technical viability of the project. It involves carrying out several activities such as
collection of basic information relating to the software  for example data items that would be input to the system, the processing
required to be carried out on these data, the output data required to be
produced by the system, as well as various constraints on the
development.

REQUIREMENT ANALYSIS AND SPECIFICATION
This phase aims at garnering all the needs and requirements of a client and document it properly as software requirement and specification document. It involves requirements gathering and analysis as well as specification.

DESIGN
In this phase, the software requirement and specification document is transformed into a structure suitable for implementation and is made ready for coding.

CODING AND UNIT TESTING
During this phase, software design is translated into codes on the computer as source code for execution and ensure its working according to design. This phase is sometimes referred to as the implementation phase.

INTEGRATION AND SYSTEM TESTING
At this stage, various modules
making up a software are integrated in one shot. Usually, integration of various modules are normally carried out
incrementally over a number of steps. During each integration step,
previously planned modules are added to the partially integrated system and
the resultant system is tested. Finally, after all the modules have been
successfully integrated and tested, the full working system is obtained.
System testing is carried out on this fully working system.

MAINTENANCE
This include corrective maintenance carried out to correct errors not discovered during the development phase, perfective maintenance to improve performance or enhance funtionality based on clients requirements.
    
Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

The waterfall methodology follows a linear and sequential approach in the execution of each phase. It is predictive as each phase is executed according plan, controlled and tends avoid any deviation.
Its phases are requirements and specification, Design, implementation, Testing, Deployment and maintenance
It is rigidly structured and so much focuses on documentation.

while 

Agile methodology is iterative i.e progressively  incremental with improvements, refinement and advancement at each stage. Its phases are sprint planning, development, review and retrospect. 
It harps on collaboration, customer involvement and rapid delivery.

Comparison:

Criterion                                   Waterfall vs. Agile
1. Approach: Linear|     Iterative  2. Flexibility:Low |    High
3.  involvement:Limited| Continuous
4. Documentation:crucial| Minimal
5. Riskmanagement:Predictv|Adaptive
6. Time-to-market:Longer|  shorter

 Application scenario for: 
A.  waterfall methodology
whereby;
* a well defined and stable requirements. 
* strict documentation as per regulations.
* scope and small scope
are needed.

B.  Agile methodology
whereby;
* specification & requirements are dynamic
* customer involvement is crucial
*  rapid delivery and iteration
are needed
  
Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

In a software engineering team, the roles of a Software Developer, Quality Assurance (QA) Engineer, and Project Manager (PM) are distinct but interconnected, each playing a crucial part in delivering successful software projects.

i. Software Developer

Roles and Responsibilities:

Coding: Writing and maintaining the code for software applications based on technical and functional specifications.

Designing: Participating in the design of system architecture, databases, and user interfaces to ensure robust and scalable solutions.

Problem-Solving: Debugging and fixing issues in the code, optimizing performance, and resolving technical challenges.

Collaboration: Working closely with other developers, QA engineers, and designers to implement features and functionalities.

Documentation: Documenting code, design decisions, and technical requirements to ensure clarity for future developers and maintainers.

Testing: Performing unit tests to ensure the code functions as expected before passing it to QA.

ii. Quality Assurance (QA) Engineer

Roles and Responsibilities:

Testing: Creating, maintaining, and executing test plans, test cases, and test scripts (manual or automated) to ensure the software meets quality standards.

Bug Reporting: Identifying and reporting bugs, issues, and inconsistencies in the software to developers, and verifying fixes.

Performance Testing: Ensuring that the software performs well under various conditions, such as load testing and stress testing.

Test Automation: Designing and implementing automated test suites to increase efficiency and reliability in testing repetitive scenarios.

Collaboration: Working closely with developers to ensure early detection of bugs and issues and to help guide the development process towards quality.

Regression Testing: Running tests after code changes to ensure that existing features and functionalities are not broken.


iii. Project Manager (PM)

Roles and Responsibilities:

Planning: Defining the scope of the project, setting clear objectives, and creating a project plan, timeline, and budget.

Coordination: Facilitating communication and coordination between team members (developers, QA engineers, designers) and stakeholders (clients, management).

Risk Management: Identifying potential risks and issues that could impact the project timeline or success, and working to mitigate them.

Monitoring Progress: Tracking the projectâ€™s progress, ensuring it stays on schedule, within scope, and on budget.

Stakeholder Management: Serving as the primary point of contact between the team and stakeholders, communicating progress, changes, and issues.

Resource Allocation: Managing team resources, ensuring that team members have what they need to complete their tasks efficiently.


Each of these roles complements the others in delivering a high-quality software product within the defined constraints of time, cost, and scope.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

Integrated Development Environments (IDEs) and Version Control Systems (VCS) are crucial tools in modern software development, streamlining workflows and ensuring code quality and collaboration.

Importance of IDEs:

An Integrated Development Environment (IDE) is a software suite that provides comprehensive tools for developers to write, test, and debug code. It integrates various tools into a single user interface to simplify and speed up the development process. IDEs typically include a source code editor, automation tools, a debugger, and sometimes an interpreter or compiler.

Key Benefits:

1. Efficiency: IDEs provide code completion, syntax highlighting, and error detection, which make coding faster and reduce errors.


2. Debugging: Built-in debuggers help developers identify and fix issues quickly by setting breakpoints, stepping through code, and viewing variables in real-time.

3. Version Integration: Many IDEs support direct integration with Version Control Systems (VCS) such as Git, making it easy to manage code changes.

4. Language Support: IDEs often support multiple programming languages, allowing developers to work on different types of projects within the same environment.
   
Examples of IDEs:

Visual Studio Code: A lightweight, open-source IDE from Microsoft that supports multiple programming languages and extensions.

IntelliJ IDEA: A robust IDE, particularly popular for Java development, with smart code navigation and deep integration with build tools.

PyCharm: A dedicated IDE for Python, offering advanced features like code analysis and web development support.

Importance of VCS:

A Version Control System (VCS) is a tool that tracks changes to code over time. It allows multiple developers to collaborate on a project without overwriting each other's work and helps in managing and maintaining the history of changes.

Key Benefits:

1. Collaboration: In team environments, VCS allows multiple developers to work on the same project simultaneously by creating branches and merging them without conflicts.

2. History Tracking: VCS maintains a complete history of all code changes, making it easy to revert to previous versions if necessary.

3. Backup: Code is stored in a central repository, ensuring there is always a backup in case of local failures.

4. Code Review and Quality Control: With VCS, developers can perform code reviews by comparing changes before merging them into the main branch, improving code quality.

Examples of VCS:

Git: The most widely used distributed version control system, popular for its branching and merging capabilities. It is often paired with services like GitHub or GitLab for remote repository hosting.

Subversion (SVN): A centralized version control system, often used in large enterprises, where all changes are stored on a central server.

Mercurial: Another distributed VCS similar to Git, though it emphasizes simplicity and ease of use.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

#Part 2: Introduction to AI and Prompt Engineering

Define prompt engineering and discuss its importance in interacting with AI models.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
